#include "s_storage.fc";
#include "s_ston_fi.fc";
#include "../params.fc";
#include "../common.fc";
#include "../storage.fc";
#include "../op_codes.fc";
#include "../errors.fc";
#include "../factory/f_params.fc";
#include "../imports/i_stdlib_modern.fc";
#include "../utils/u_jetton_utils.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::excesses) {
        return ();
    }

    if (op == op::buy) {
        load_data();

        var initial = my_balance - msg_value == 0;

        buy(msg_value, in_msg_body, sender_address, initial, true, query_id);

        ;; Check if we reached max liquidity (300 TON)
        if (ctx_ton_liq_collected >= max_liquidity_ton) {
            deposit_liquidity_to_ston_fi(query_id);
            send_fee(ctx_liquidity_fee, op::liquidity_fee_payout, query_id, ctx_custom_payload);
            ctx_total_supply = max_supply;
            ctx_phase = phase::listed;
        }

        store_data();

        return ();
    }

    if (op == op::sell_notification) {
        load_data();
        sell(msg_value, in_msg_body, sender_address, query_id);
        store_data();

        return ();
    }

    if (op == op::unlock_request) {
        load_data();
        unlock(in_msg_body, sender_address, query_id);
        store_data();

        return ();
    }

    if (op == op::burn_notification) {
        load_data();
        handle_burn_notification(in_msg_body, sender_address, query_id);
        store_data();

        return ();
    }

    if (op == op::transfer_notification) {
        handle_transfer_notification(in_msg_body, sender_address, query_id);
        return ();
    }

    if (op == op::provide_wallet_address()) {
        load_data();

        provide_wallet_address(msg_value, fwd_fee, in_msg_body, query_id, sender_address);

        return ();
    }

    throw(err::unknown_op);
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
    load_data();
    return (ctx_total_supply, 0, address_none(), ctx_content, ctx_wallet_code);
}

slice get_wallet_address(slice owner_address) method_id {
    load_data();
    return calculate_user_jetton_wallet_address(owner_address, my_address(), ctx_wallet_code);
}

;;
;; BCL specific methods
;;
var coin_price() method_id {
    load_data();
    return calc_coin_price();
}

var coins_for_tons(int tons) method_id {
    load_data();

    var (fees, coins, tons_consumed) = calc_coins_for_tons(tons);

    if (coins <= 0) {
        return (0, 0);
    }

    return (fees, coins);
}

var tons_for_coins(int coins) method_id {
    load_data();

    var (fees, tons) = calc_tons_for_coins(coins);

    if (tons <= 0) {
        return (0, 0);
    }
    return (fees, tons);
}

var get_bcl_data() method_id {
    load_data();

    var (full_price_ton_fees, full_price_ton_need) = calc_tons_for_all_coins();
    slice ref = ctx_addresses.begin_parse();

    return (
        dex_type::ston_fi,
        ctx_total_supply,
        threshold_supply,
        max_supply - threshold_supply,
        ctx_factory,
        ctx_author,
        ctx_content,
        ctx_fee_recipient,
        ctx_buy_fee_basis,
        ctx_sell_fee_basis,
        ctx_last_trade_date,
        ctx_phase,
        ctx_ton_liq_collected,
        ctx_liquidity_fee,
        full_price_ton_need,
        full_price_ton_fees,
        ref~load_msg_addr(),
        ref~load_msg_addr()
    );
}

